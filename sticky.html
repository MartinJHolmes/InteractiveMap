<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Map + Phone-proof Centered InfoBox</title>
<style>
  html,body { margin:0; padding:0; height:100%; -webkit-text-size-adjust:100%; }
  body { font-family: Arial, sans-serif; overflow-x:auto; }

  /* map kept at its real size (880x844) */
  #map {
    position: relative;
    width: 880px;
    height: 844px;
    border: 1px solid #000;
    margin: 20px auto;
  }
  #map img { width:880px; height:844px; display:block; }

  .dot {
    position: absolute;
    width: 14px;
    height: 14px;
    background: blue;
    border-radius: 50%;
    border: 2px solid white;
    transform: translate(-50%,-50%); /* center the visual dot */
    cursor: pointer;
  }

  /* overlay covers viewport using fixed edges (avoid 100vh quirks) */
  #overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.45);
    display: none;
    z-index: 9999;
    /* NOTE: don't rely on flex centering on mobile — we'll position the box by JS */
  }

  /* infoBox: we'll position with JS (pixel left/top). Keep no CSS transform. */
  #infoBox {
    position: fixed; /* necessary so left/top are viewport-relative */
    display: none;
    z-index: 10000;
    width: 280px;
    box-sizing: border-box;
    padding: 14px;
    background: #fff;
    border-radius: 8px;
    border: 1px solid #333;
    box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  }
  #infoBox h3 { margin:0 0 8px 0; font-size:16px; }
  #infoBox .close {
    position: absolute;
    right: 10px;
    top: 8px;
    cursor:pointer;
    font-weight:700;
  }

  textarea { width: calc(100% - 20px); margin:10px; height:120px; }
</style>
</head>
<body>

<h1 style="margin:10px">Valencia Old Town</h1>

<div id="map">
  <img src="images/Valencia-OldTown.jpg" alt="Valencia Old Town map">
  <!-- sample dots -->
  <div class="dot" style="left:440px; top:400px" onclick="showInfo('Center Dot','Example description')"></div>
  <div class="dot" style="left:200px; top:200px" onclick="showInfo('Dot 2','Another description')"></div>
</div>

<!-- overlay and infoBox live as direct children of body -->
<div id="overlay" onclick="hideInfo()"></div>

<div id="infoBox" role="dialog" aria-modal="true" aria-labelledby="infoTitle">
  <span class="close" aria-label="Close" onclick="hideInfo()">✖</span>
  <h3 id="infoTitle">Title</h3>
  <div id="infoDesc">Description</div>
</div>

<textarea id="log" readonly placeholder="GPS messages will appear here..."></textarea>

<script>
(function () {
  const overlay = document.getElementById('overlay');
  const infoBox = document.getElementById('infoBox');
  const infoTitle = document.getElementById('infoTitle');
  const infoDesc = document.getElementById('infoDesc');

  // centerInfoBox: compute pixel left/top so the box is centered in the VISUAL viewport
  function centerInfoBox() {
    // only center if visible
    if (getComputedStyle(infoBox).display === 'none') return;

    // measure viewport (window.innerWidth/innerHeight are best for phone)
    const vw = window.innerWidth || document.documentElement.clientWidth;
    const vh = window.innerHeight || document.documentElement.clientHeight;

    // after layout, measure box size
    // ensure box is visible for accurate measurement
    infoBox.style.display = 'block';
    // small timeout to allow browser to compute layout (safer on some mobile browsers)
    requestAnimationFrame(() => {
      const bw = infoBox.offsetWidth;
      const bh = infoBox.offsetHeight;

      // compute left/top so the box is centered in the visible area
      const left = Math.max(0, Math.round((vw - bw) / 2));
      const top  = Math.max(0, Math.round((vh - bh) / 2));

      // apply pixel positions (fixed positioning -> viewport-relative)
      infoBox.style.left = left + 'px';
      infoBox.style.top  = top  + 'px';
    });
  }

  // call centerInfoBox when visible and on events that change viewport
  function centerIfVisible() {
    if (getComputedStyle(infoBox).display === 'none') return;
    centerInfoBox();
  }

  // show/hide API
  window.showInfo = function(title, desc) {
    infoTitle.textContent = title || '';
    infoDesc.textContent = desc || '';
    overlay.style.display = 'block';
    infoBox.style.display = 'block';
    // ensure no CSS transform is in effect on the box itself
    infoBox.style.transform = 'none';
    // always use fixed
    infoBox.style.position = 'fixed';
    // compute center AFTER it's visible
    centerInfoBox();

    // small debug: detect ancestor transforms that can break fixed positioning
    setTimeout(detectAncestorTransforms, 50);
  };

  window.hideInfo = function() {
    overlay.style.display = 'none';
    infoBox.style.display = 'none';
  };

  // re-center on resize/orientationchange/scroll (scroll may not change viewport but mobile address bar might)
  window.addEventListener('resize', centerIfVisible);
  window.addEventListener('orientationchange', () => setTimeout(centerIfVisible, 200));
  // some mobiles change layout on scroll/toolbar hide — keep centering while visible
  window.addEventListener('scroll', centerIfVisible, true);

  // helpful debug: if any ancestor of <body> (including html or body) has transform != none, fixed may behave relative to that ancestor
  function detectAncestorTransforms() {
    let el = document.documentElement; // <html>
    const problemNodes = [];
    while (el) {
      try {
        const cs = window.getComputedStyle(el);
        if (cs && cs.transform && cs.transform !== 'none') {
          problemNodes.push({ el, transform: cs.transform });
        }
      } catch (e) {
        // ignore cross-origin or other weird nodes
      }
      el = el.parentElement;
    }
    if (problemNodes.length) {
      console.warn('Ancestor(s) have CSS transform which can break position:fixed on some mobile browsers. Targets:', problemNodes);
      // show a non-intrusive hint in the console and in the textarea for visibility
      const msg = 'WARNING: ancestor has transform; fixed positioning may be broken on this browser.';
      appendLog(msg);
    } else {
      appendLog('No ancestor transforms detected.');
    }
  }

  // small helper to append log to textarea
  function appendLog(text) {
    const log = document.getElementById('log');
    if (!log) return;
    log.value += (new Date()).toLocaleTimeString() + ' - ' + text + '\n';
    log.scrollTop = log.scrollHeight;
    console.log(text);
  }

  // initial detection (helpful when page loads)
  window.addEventListener('load', () => {
    detectAncestorTransforms();
  });

  // accessibility: close on Escape
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'Escape') hideInfo();
  });

  // expose center function for debugging
  window._centerInfoBox = centerInfoBox;
})();
</script>
</body>
</html>
